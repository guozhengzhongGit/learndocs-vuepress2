## 观察者模式

实现一对多关系解耦的行为型设计模式，主要涉及两个角色：

- 观察目标
- 观察者

多个观察者对象同时监听某一个目标对象；当目标对象状态发生变化时，通知所有观察者对象，使他们能够自动更新

被观察的目标对象里持有观察自己的观察者对象，它知道自己被哪些观察者对象订阅，有增加订阅者、通知订阅者、移除订阅者这个三个基本能力，当自身状态发生变化时，通过 notify 方法通知所有的观察者 update

观察者非常简单，它的行为只有两个，被通知和去执行，本质上是接受目标对象的调用，并且这一步在目标对象类里已经做掉了，所以 observer 只需要实现 update 方法，供目标对象调用，在 update 方法中可以执行 observer 自定义的业务代码

### 特点

观察者要**直接订阅**观察目标

@[code js](./src/observer.js)

## 发布订阅模式

小明想买房子，但还没开盘，不过他只需要把自己的手机号留给售楼处，等到楼盘开售，售楼处就会打电话通知他

并且想买房子的不止小明，还有小红、小白等人，售楼处都保存了他们的联系方式，在合适的时间去通知所有顾客

如果再有新的购房者出现，售楼处只需要多保存一个联系方式即可

异步编程

对象之间解耦合

一个对象里保存了一份回调列表

### 特点

### 与发布订阅模式比较

> 发布订阅模式基于一个事件总线，希望接收通知的对象即 subscriber 也就是订阅者通过自定义事件订阅事件总线，发布事件的对象即 publisher 通过发布事件的方式通知各个订阅了该事件的 subscriber

**区别在于**

- 观察者模式中观察了 subject 的一系列 Observer 对象在被通知后只能执行同一个特定的更新方法，而发布订阅模式中则可以基于不同主题去执行不同的自定义事件
- 观察者模式中目标对象和观察者对象之间联系的更紧密，耦合性更高，有很强的依赖关系，目标对象收集和维护观察者，并在状态变化时主动通知观察者更新；发布订阅中则彻底解耦
- 发布订阅在发布者和订阅者之间需要有一个中间人，发布者发布事件名和参数到中间人，中间人像事件的订阅者发送参数
