---
title: "高频题目-陈述原理"
tags:
  - 原理
  - prototype
  - 原型
  - 原型链
---

# 高频题目-JS 陈述类

## 001. 原型和原型链

JS 是基于原型机制实现的继承。我们一般通过构造函数生成实例对象，实例对象继承了它原型对象上的属性和方法，它的原型对象指向了构造函数的 prototype 属性，而原型对象也是一个对象，它自己的原型对象也是其构造函数的 prototype 属性即 Object.prototype，Object.prototype 这个对象的原型指向 null，到达原型链的终点；在 JS 中函数也是一个对象，函数对象也有自己的原型对象即 Function.prototype；Function 构造函数本身也是一个对象，其原型对象是构造函数的 prototype 属性（自己就是构造函数因此有 Function.**proto** === Function.prototype）同理 Function.prototype 这个对象的原型也指向 Object.prototype。这样就构成了从普通实例对象或者函数对象到 null 的原型链

## 002. instanceof 原理

查看 instanceof 运算符右侧构造函数的 prototype 属性是否出现在运算符左侧对象的原型链上

## 003. 原型链和作用域链的区别

- 作用域链是指变量查找的路径，用来查找变量标识符的，是词法作用域的一种实现方式。
  > 词法作用域即静态作用域，指函数的作用域在函数定义的时候就确定好了，与之对应的是动态作用域，如 bash 语言
- 原型链是用来查找对象属性的。沿着对象的原型一级一级查找属性，这条查找属性的路径称为原型链，是原型继承的一种实现方式

- 二者的不同: 首先二者的作用完全不同，其次查找的终点不同，原型链查找的终点是 null，作用域链的终点是全局作用域；此外当在原型链中找不到一个属性的时候，会得到一个 undefined，而试图访问一个作用域链中不存在的变量则会抛出一个引用错误

## 004. JS 中数据类型的判断

- 使用 typeof 运算符可以正确判断基本数据类型里除 null 之外的其他数据类型和引用类型里的函数对象
- 使用 instanceof 运算符可以判断一个对象是否是某个构造函数的实例
- 使用 Array.isArray() 可以便捷的判断数组
- Object.prototype.toString.call(value) 可以正确判断所有数据类型

## 006. 中断 promise 链的方法

返回一个 pending 状态的 promise 即可

## 007. typeof 为什么对 null 显示为 object

## 008. null 和 undefined 的区别

- null 表示此处为空，即没有值，而 undefined 表示未定义
- 使用 Number() 构造函数转换时，null 结果为 0；undefined 为 NaN
- undefined 表示该值已声明，但没有被赋值

## 009. 所有事件都冒泡吗

不是。blur、focus、mouseenter 和 mouseLeave 不冒泡

## 010. Promise 的优缺点

### 优：

- 多个回调函数嵌套调用，外部回调函数异步执行的结果是内部回调函数执行的条件，这样的场景用传统纯回调的方式去处理会形成“回调地狱”，代码互相嵌套，并且每一个函数都得单独做异常处理，使得调试和维护都变得异常困难。而 promise 允许链式调用，统一使用 then 方法依次注册回调函数，并在 promise 链的末尾使用 catch 方法捕获错误，将嵌套的回调函数铺平了，很好的解决了“回调地狱”的问题

- promise 状态一经确定就永不再变，任何时候都可以拿到异步任务的结果。

### 缺：

- 一旦新建就立即执行，无法取消

- 当处于 pending 状态时，无法得知目前进展到哪一阶段，其实就是没有提供 onProgress

- promise 内部产生的错误即使未经捕获也不会影响到外面代码的执行，这导致 promise 链中的错误很容易被忽略，所以推荐在 promise 链的末尾添加一个 catch 方法

## 011. 描述下虚拟 DOM

- 本质是用一个 JS 对象去描述 DOM 节点，对真实 DOM 的一层抽象。在浏览器中直接操作真实 DOM 是很昂贵的，JS 引擎和渲染线程需要互相通信，并且每个 DOM 对象上挂载着很多属性，自身也比较庞大，频繁操作真实 DOM，会产生额外的的性能开销，因此我们需要这一层抽象，在发生改变后对比新旧两棵虚拟 DOM 树，尽可能一次性将差异更新到 DOM 中

- 更重要的意义是使得跨平台开发成为可能，可以把代表 DOM 的 JS 代码编译成其他平台的代码

## 012. call、apply 和 bind

#### 03. 闭包

---

#### 04. 跨域

---

#### 05. 跨域的解决办法

---

#### 06. 模块化

---

#### 07. 数组的方法

---

#### 08. 如何从数组中删除一个元素

---

#### 09. 字符串的方法

---

#### 10. string 的 replace 方法怎么用

---
